require File.dirname(__FILE__) + '/helper'

class TestProfile < Camping::ModelTest
  DOMAIN = 'my-pasaporte.com'
  fixtures :pasaporte_profiles
  
  def test_assumes_localhost_as_default_domain
    @profile = Profile.new
    assert_equal 'localhost', @profile.domain_name
  end
  
  def test_requires_nickname_and_domain
    @profile = Profile.new
    
    deny @profile.valid?, "The profile without a nickname and a domain name is invalid"
    @profile.nickname = 'xxx'
    @profile.domain_name = ''
    
    deny @profile.valid?, "The profile without a domain name is invalid"
    
    @profile.domain_name = 'somedomain'
    assert @profile.valid?
  end
  
  def test_domain_name_and_nickname_are_protected
    @profile = Profile.new
    @profile.attributes = {:nickname => 'xyz', :domain_name => 'google'}
    
    assert_not_equal @profile.nickname, 'xyz'
    assert_not_equal @profile.domain_name, 'google'
  end
  
  def test_find_or_create_by_domain_and_nickname_exempted_from_attribute_protection
    prof = create("julik", "julik.nl")
    assert prof.valid?
    deny prof.new_record?
    assert_equal 'julik.nl', prof.domain_name
    assert_equal 'julik', prof.nickname
    prof = create("julik", "julik.nl")
    assert prof.valid?
    deny prof.new_record?
    assert_equal 'julik.nl', prof.domain_name
    assert_equal 'julik', prof.nickname
  end
  
  def test_secret_integer_generated
    secrets = %w( foo bar baz daz daing ).map do | word |
      prof = Profile.find_or_create_by_nickname_and_domain_name(word, word)
      deny prof.new_record?
      prof.secret_salt
    end
    assert_equal secrets.length, secrets.uniq.length,
      "All generated secrets should be autogenerated and unique"
  end
  
  def test_enforces_unique_nickname_and_domain
    prof1 = create("MisterZed", "google.com")
    prof2 = Profile.new do | p |
      p.nickname = "MisterZed"
      p.domain_name = "google.com"
    end

    assert prof1.valid?, "The first created should be valid"
    deny prof2.valid?, "The second one clashes"
    
    prof2.domain_name = "yahoo.com"
    assert prof2.valid?, "The second one is valid too because there are no clashes anymore"
  end

  def test_validates_both_delegate_urls
    p = create("strained", "test.host")
    assert p.valid?, "The newly created profile should be valid"
    
    p.openid_server = "watatoe.com/openid"
    deny p.valid?, "The profile cannot be valid with only the server URL"
    assert_not_nil p.errors[:openid_delegate], "Should require delegate URL"
    
    p.openid_delegate = "watatoe.com/openid/backend"
    assert p.valid?, "As two URLs are present the profile becomes valid"
  end
  
  def test_normalizes_both_delegate_urls
    p = create('julik', DOMAIN, 
      :openid_server => 'xxx.com', :openid_delegate => 'xyz.org/x')
    assert_equal 'http://xxx.com/', p.openid_server, 
      "The URL should be normalized with HTTP scheme and trailing slash"
    assert_equal 'http://xyz.org/x', p.openid_delegate, 
      "The URL should be normalized with HTTP scheme"
  end
  
  def test_to_sreg_fields_by_default
    p = create('julik', DOMAIN, 
      :email => 'foo@var.com', :dob => Date.parse("10.15.1983"))
    all_fields = p.to_sreg_fields
    r = {"dob"=>"1983-10-15", "nickname"=>"julik", "email"=>"foo@var.com"}
    assert_equal r, all_fields
  end
  
  def test_to_sreg_fields_with_requested_fields
    p = create('julik', DOMAIN, 
      :email => 'foo@var.com', :dob => Date.parse("10.15.1983"))
    partial_fields = p.to_sreg_fields([:dob, :gender, :country])
    r = {"dob"=>"1983-10-15"}
    assert_equal r, partial_fields
  end
  
  def test_to_sreg_fields_with_lotso_data
    mh = Profile.find(1)
    ref = {"dob"=>"1953-01-12", "postcode"=>"1234", 
      "nickname"=>"monsieur-hulot", 
      "country"=>"fr", "fullname"=>"Monsieur Hulot", "gender"=>"m"}
    assert_equal ref, mh.to_sreg_fields
  end
  
  def test_openid_requestor
    begin
      o = Pasaporte::ALLOW_DELEGATION
      silence_warnings { Pasaporte.const_set(:ALLOW_DELEGATION, true) }
      
      mh = Profile.find(1)
      deny mh.delegates_openid?
      assert mh.update_attributes(
        :openid_server => 'http://tativille.fr/oid',
        :openid_delegate => 'http://tativille.fr/oid/proc'
      )
      
      assert mh.delegates_openid?, "delegates_openid? should be true"
      assert mh.update_attributes(:openid_server => '', :openid_delegate => '')
      deny mh.delegates_openid?, "There are no URLS - no delegation happens"
      
      assert mh.update_attributes(
        :openid_server => 'http://tativille.fr/oid',
        :openid_delegate => 'http://tativille.fr/oid/proc'
      )
      silence_warnings { Pasaporte.const_set(:ALLOW_DELEGATION, false) }
      deny mh.delegates_openid?, "Delegation is turned off - "+
       "no delegation happens"
    ensure
      silence_warnings { Pasaporte.const_set(:ALLOW_DELEGATION, o) }
    end
  end
  
  private
    def create(nick, domain, extras = {})
      p = Profile.find_or_create_by_nickname_and_domain_name(nick, domain)
      p.update_attributes(extras) if extras.any?
      p
    end
end